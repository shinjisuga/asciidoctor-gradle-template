include::../attribute.adoc[]


== アジェンダ

* はじめに
* 開発ルールの説明
** 質疑応答は適時

== セッションの目的

開発ルールの概要を説明しますが、最初からすべての内容を理解しルールを守って開発することは困難です。
そのため、このセッションでは大枠のプロセスやルールを理解し初期の進め方やルールを合意することを目的とします。
実際に開発をしながら、開発プロセスやルールを改善します。

== はじめに

開発運用者が一定の統制下において、共同して効率的に気持ちよく仕事をするためのルールを定めます。開発運用者が開発ルールを正しく理解し、合意したうえで開発に取り組むことが重要です。

=== 開発ルール設定の狙い

プロジェクトの品質と効率を向上させ、開発運用者間の混乱を避けるためです。開発ルールを設定することで一貫性と予測可能性が保たれ、誤解やエラーの可能性が低減されます。また、新たにプロジェクトに参加するメンバーが迅速に開発作業に取り組めるようになるというメリットもあります。これらは全て、開発プロセスをスムーズに進め、期限内に価値・品質の高い製品を提供するために重要です。

=== 想定読者

* プロダクトオーナー
* プロジェクトに関係するすべての開発運用者

=== 開発ルールの改訂

より効率的に、より気持ちよく仕事をするために改訂することを認めます。改訂は、開発運用者の正しい理解と合意を必要とします。 改訂案を開発運用者に周知するとともに合意を得たうえで改訂してください。

改訂履歴は、GitHub上に保存されるため人的に保存しません。

TIP: 本資料は、GitHub上で管理する想定です。

=== 開発ルールの前提

IaC(Infrastructure as Code)を前提としたモダンな技術とそれらを用いた開発運用プラクティスの集合とも言われるGitOpsを採用し、それらを前提とした開発ルールを策定します。GitOpsを採用することで、環境の変更操作がGitを経由するため監査の容易性が向上し、人に高権限を付与する頻度を低減します。

=== GitOpsとは

GitOpsは、ソフトウェア開発やインフラストラクチャ管理における開発運用モデルの一つとされ、Gitを信頼できる唯一の情報源として利用します。システムの現在の状態と望ましい状態をGitリポジトリで管理し、差分が生じた時に自動的に修正を行う手法です。

このモデルは開発運用モデルのプロセスをシンプルにし、フレキシブルで迅速な開発とリリースを可能にします。また、システム全体を自動的に監視し、望む状態に保つことで、エラーやセキュリティリスクの低減を可能にします。

GitOpsではインフラストラクチャをコードで管理（Infrastructure as Code）し、開発運用者は変更をプルリクエストとして送信します。変更が承認され、環境ブランチへマージされると自動化ツールがこれをチェックして環境へ反映します。また現在の状態とリポジトリの状態が一致しているか監視し、差分がある場合は検出します。

`Application Repository` と `Environment Repository` に分けて、それぞれのコード・パイプラインを管理します。

image:./gitops-overview.drawio.png[]

Application Repository::
アプリケーションの実行・テストコードやビルド設定などを管理します。そのパイプラインは、ビルドやテスト、アーティファクトの登録までを実施します。

Environment Repository::
アプリケーションの実行環境の構成ファイル、デプロイ・リリース設定ファイルを管理します。そのパイプラインは、アーティファクトを用いてデプロイおよびリリースします。

==== 重要なポイント

* Gitでインフラレイヤーをバージョン管理
* Git操作で開発からデプロイまでの承認を含むすべてのプロセスを実行
* Git非経由の変更差分を警告
* Push型とPull型が存在しており、Pull型が主流且つ推奨

==== ベネフィット

* プロダクトオーナー
** 環境の変更操作がGitを経由するため、監査の容易性が向上
** 人に高権限を付与する頻度を低減可能
* 開発運用者
** 慣れ親しんだGitベースのワークフローでいつも通り開発可能
** 基盤チーム待ちのコードフリーズ無しで自分たちのペースでコードを記載可能
** 手順書ベースで煩雑且つ信頼性の低いワークフローから、効率的で信頼性の高い自動化ワークフローに移行可能
** 障害の原因が特定が容易となり、復旧が高速化または自動復旧可能

== リポジトリ戦略

ポリレポと モノレポという大別して二つの考え方があるが、認知負荷の低さとパイプラインの保守運用性を優先し ポリレポ を採用します。 モノレポを採用することで、開発の容易性を向上させることもできますが、エコシステムの充実が不十分であり比較的高度なパイプラインの運用保守が必要となります。モノレポ は、固有の知識やスキルセットが必要となりますが、現時点(2024/06/19)では一般的な認知度はそれほど高くなく、経験者の獲得は難しく未経験者には学習が必要となります。

TIP: ポリレポとは、ある一定粒度でリポジトリを分割して、複数のリポジトリで管理するアプローチ

TIP: モノレポとは、複数のプロジェクトまたはシステムをまとめて、単一のリポジトリで管理するアプローチ

=== リポジトリトポロジー

本プロジェクトにおけるリポジトリの種類と包含関係を下図に示します。 `Frontend Service Repository` と `Backend Service Repository` はリポジトリを分けます。 また、図中の各Repositoryは、単一のリポジトリでは無く分類を示しています。これは、`Backend Service Repository` など図中で緑色のリポジトリが複数存在することを示しています。

image::./repository-structure-topology.drawio.png[]


=== リポジトリ種別一覧

Application Repository::
各種サービスやライブラリーリポジトリ群です。これらのリポジトリ群は、各種サービス、テスト、ビルドツール、コンテナ、CIパイプラインのコードやそれらの設定情報を有します。


Frontend Service Repository::
フロントエンド用のリポジトリ。パイプラインの最終成果物は、単一パッケージとなりバージョン管理します。

Backend Service Repository::
バックエンド用のリポジトリ。パイプラインの最終成果物は、単一コンテナとなりバージョン管理します。

(optional)Frontend Library Repository::
フロントエンドサービスが分割・新規作成された際に共通化したいライブラリのコードを管理するリポジトリ。パイプラインの最終成果物は、単一パッケージとなりバージョン管理され、フロントエンドサービスで利用します。

(optional)Backend Library Repository::
バックエンドサービスが分割・新規作成された際に共通化したいライブラリのコードを管理するリポジトリ。パイプラインの最終成果物は、単一ライブラリとなりバージョン管理され、バックエンドサービスで利用します。

(optional)Ops Optimize Service Repository::
開発運用業務を効率化したり、自動化するためのサービスのコードを管理するリポジトリ。パイプラインの最終成果物は、単一コンテナとなりバージョン管理します。

Environment Repository::
環境情報やデプロイ、リリース設定を保持するリポジトリの総称。各環境ブランチへ変更が反映されることにより、自動的に当該環境の設定が変更します。

Infra Repository::
AWSなどのクラウドリソースの設定情報を有します。

(optional)Cluster Repository::
クラスタを利用する場合の選択肢となります。infraリポジトリ内で管理しても良いが、運用が難しい場合に利用します。Kubernetesなどのクラスタおよびそのコンテナの設定情報を有します。

Other Repository::
`Application Repository` と `Environment Repository` に該当しないその他のリポジトリ群です。

Docs Repository::
プロジェクトの運営ルールや開発ルールや、リポジトリを跨る設計情報などのドキュメント配置先です。また、PBIやIssueを保持します。

Template Repository::
リポジトリを新規に作成する際の雛型になるリポジトリ。即座に開発を始めるためおよび、負の影響からリポジトリを保護するための初期設定やファイルを保持しています。

etc::
全てのリポジトリに対して、共通的なテンプレートを提供できる .githubなどのメタリポジトリや、汎用的な用途のprojectリポジトリなど。

=== リポジトリ命名規約

`<プロジェクト識別子>-<固有名>`

例）

* プロジェクト識別子が、 xxx
* 固有名が、yyyデータ登録サービスの場合は、yyydata-register-service
* xxx-yyydata-register-service

プロジェクト識別子::
小文字英数字

固有名::
小文字英字とし複数単語からなる場合は、単語の区切りをハイフンとします。

== ブランチ戦略

`Application Repository` と `Environment Repository` のそれぞれ異なるブランチ戦略を採用します。

=== Application Repository

link:https://docs.github.com/ja/get-started/using-github/github-flow[GitHub-Flow]ベースのシンプルなブランチ戦略を採用します。シンプル且つ一般的なブランチ戦略を採用することで、認知負荷を小さく抑え生産性を向上させるとともに新規参画者の学習コストを低減します。

本プロジェクトでは、原則として、featureブランチの生存期間を３日以内とします。３日以内に作業を完了しmainブランチへマージしてください。featureブランチの生存期間が長いとコンフリクトが発生しやすくなり、付加価値を産まないコンフリクト解消に時間を取られます。そのため、機能は数日で実装が終わる程度の粒度に分割する必要があります。

image::./branch-structure-application.drawio.png[]

1.Create feature branch::
開発運用者が、機能/不具合を開発/解消するために変更用のブランチを作成します。

2.Make changes::
開発運用者が、アプリケーションのコードやテストコードの追加・修正をします。テストコードを期待動作することを確認します。

3.Create pull request::
開発運用者が、mainブランチへ向けたプルリクエストを作成し、プルリクエストテンプレートに説明を記載します。テストなどのパイプラインがトリガーされ、プルリクエストに結果が表示されます。

4.Review & Approve::
プルリクエスト作成者以外の開発運用者２名が、プルリクエストの説明や変更内容、テスト結果を確認し、問題や懸念があればレビューコメントを付けます。問題や懸念が解消された場合は承認します。

5.Merge pull request::
プルリクエスト作成者が、プルリクエストをマージし、バージョンの付与やそのバージョンのアーティファクト(コンテナやパッケージ)を生成します。プルリクエスト作成者以外の承認が２以上無い場合は、 `main` ブランチへマージできません。

=== Environment Repository

初期設定として、環境毎に環境ブランチを作成します。featureブランチで設定変更を実施し、以下のようなフローで運用します。
これにより、開発環境でテストされていない構成変更を、本番環境に直接反映することを防止するとともに、本番環境の変更に管理者承認を必須とします。

image::./branch-structure-environment.drawio.png[]


1.Create feature branch::
開発運用者が、変更を開発環境に反映するためのブランチを作成します。

2.Make changes::
開発運用者が、変更を開発環境に反映するために、環境構成情報を変更します。
例えば、アプリケーションコンテナのバージョンを 1.1.1 から、 1.1.2に変更するなどです。

3.Create pull request::
開発運用者が、devブランチへ向けたプルリクエストを作成し、プルリクエストテンプレートに説明を記載します。テストなどのパイプラインがトリガーされ、プルリクエストに結果が表示されます。

4.Review & Approve::
プロダクトオーナーが、プルリクエストの説明や変更内容、テスト結果を確認し、問題や懸念があればレビューコメントを付けます。問題や懸念が解消された場合は承認します。

5.Merge pull request::
プロダクトオーナーが、プルリクエストをマージし、開発環境の構成を変更します。デプロイに失敗した場合は、元のバージョンに戻ります。
例えば、このタイミングで、開発環境で動作するコンテナのバージョンが、1.1.1 から1.1.2に変更されます。管理者の承認が無い場合は、 `dev` ブランチへマージできず開発環境を変更できません。

6.Create pull request::
開発運用者が、devブランチからprdブランチへ向けたプルリクエストを作成し、プルリクエストテンプレートに説明を記載します。テストなどのパイプラインがトリガーされ、プルリクエストに結果が表示されます。

7.Review & Approve::
プロダクトオーナーが、プルリクエストの説明や変更内容、テスト結果を確認し、問題や懸念があればレビューコメントを付けます。問題や懸念が解消された場合は承認します。

8.Merge pull request::
プルリクエスト作成者が、プルリクエストをマージし、本番環境の構成を変更します。デプロイに失敗した場合は、元のバージョンに戻ります。
例えば、このタイミングで、本番環境で動作するコンテナのバージョンが、1.1.1 から1.1.2に変更されます。管理者の承認が無い場合は、 `prd` ブランチへマージできず本番環境を変更できません。


=== ブランチ命名規約

=== featureブランチ

`feature/<プロジェクト識別子>-<Issue番号>`

例）
- xxxプロジェクトで、プロジェクト識別子が xxx
- Issue番号が、1の場合

`feature/XXXX-1`

プロジェクト識別子::
小文字英数字

チケット番号::
数字で桁数のゼロパディングをしない。

== 開発の流れ

スキーマ駆動で開発を進めます。関係者全員でサービスＡＰＩのインタフェースを設計します。インタフェース設計後にフロントエンドとバックエンドを並行して開発します。
これにより、フロントエンドとバックエンドの並行開発を可能し、双方での認識相違を未然に防止するとともにコード生成ツールをプロセスに組込むことで生産性を向上します。

=== 開発フロー

フロントエンドとバックエンドを開発する際のフローを示します。フロントエンドのみやバックエンドのみなどどちらか一方のみを開発する場合は、不要なプロセスを省略します。

image::./dev-flow.drawio.png[]

=== 開発プロセス

ユーザーストーリーマップとワイヤーフレーム作成::

プロダクトオーナーが、ユーザーストーリーマップとワイヤーフレームを作成しステークスホルダーと合意します。最終的な意思決定は、プロダクトオーナーが担います。

プロダクトバックログ作成::
プロダクトオーナーが中心となり、開発運用者と共同してユーザストーリを元にプロダクトバックログを作成し、フィードバックを元にワイヤーフレーム更新します。

サービス設計::
開発運用者が中心となり、プロダクトオーナーと共同しながらバックエンドサービスを設計します。
概念モデル、論理モデルおよび、シーケンス図などを作成します。

APIインタフェース設計::
開発運用者が共同して、APIのインタフェースをOpenAPIで定義します。これらを元にフロントエンドとバックエンドの一部のコードを自動生成し、それらを元に実装します。
自動生成されたコードの変更を禁止します。フロントエンドは、OpenAPIの定義情報を元にモックサーバを起動して開発します。

バックエンドサービス実装テスト::
開発運用者が、`Backend Service Repository` で、バックエンドサービスAPIを実装し単体テストします。
最終成果物は、ステートレスでイミュータブルなテスト済のコンテナです。コミットメッセージを元に自動的にバージョニングします。

バックエンド開発環境デプロイ::
開発運用者が、最終成果物であるコンテナを開発環境にデプロイします。デプロイは、`Infra Repository` のコード変更とdevブランチへのマージによって自動的に実施します。

フロントエンド機能実装テスト::
開発運用者が、`Frontend Service Repository` で、API呼出など動的な振る舞いを実装し単体テストします。

最終成果物は、画像などのコンテンツ、CSS、JS、HTMLなど全ての構成要素を含むビルドとテスト済のパッケージです。コミットメッセージを元に自動的にバージョニングします。

フロントエンド開発環境デプロイ::
開発運用者が、最終成果物であるパッケージを開発環境にデプロイします。デプロイは、`Infra Repository` のコード変更とdevブランチへのマージによって自動的に実施します。

結合試験::
開発運用者が、開発環境で結合試験します。ここでの主要な確認内容は、フロントエンドとバックエンドが期待通り連携し動作することです。

スプリントレビュー::
開発運用者が、開発環境でデモを実施します。開発運用者は事前にデモシナリオを検討しデモの準備をしてください。
また、プロダクトオーナーは必要に応じてステークスホルダーを招集してください。このプロセスを、次の本番環境リリースの必須条件としません。スプリントレビュー無く、プロダクトオーナーの判断で本番環境へリリースすることを認めます。これは、バグフィクスや軽微な機能変更などを迅速に提供するためです。

本番環境リリース::
開発運用者が、開発環境で動作確認済のバージョンを本番環境にリリースします。リリースは、プロダクトオーナーの承認を必須とし、`Infra Repository` のコード変更とprdブランチへのマージによって自動的に実施します。プロダクトオーナーは、リリース内容・予定日時、障害復旧計画や手順および、テスト結果を確認しリリースを承認し、問題があれば差し戻します。

== ロールと役割分担

=== ロール定義

- Po プロダクトオーナー
- Designer デザイナー
- DevOps 開発運用者
- SM スクラムマスター

=== 役割
- 〇 主担当 プロセスの主担当。
- △ 支援 主担当者を支援する。
- ◇ 承認 プロセスを承認する

=== ロールと役割対応表

[cols="5,2,2,2,2"]
|===
| プロセス
| Po
| Designer
| DevOps
| SM

|ユーザーストーリーマップ作成
|〇
|△
|△
|△

|ワイヤーフレーム作成
|△
|〇
|△
|

|プロダクトバックログ作成
|〇
|△
|△
|△

|サービス設計
|
|
|〇
|

|APIインタフェース設計
|
|
|〇
|

|バックエンドサービス実装・テスト
|
|
|〇
|

|バックエンドサービス開発環境デプロイ
|
|
|〇
|

|フロントエンドサービス機能実装・テスト
|
|
|〇
|

|フロントエンドサービス開発環境デプロイ
|
|
|〇
|

|結合試験
|
|
|〇
|

|スプリントレビュー
|
|
|〇
|◇

|本番環境リリース
|◇
|
|〇
|

|===

== バージョニング

バックエンド、フロントエンドおよびアーティファクトの種類問わず、link:https://semver.org/lang/ja/[セマンティックバージョニング]を採用します。この形式は更新履歴を分かりやすく示し、アップデートによって起こりうる問題を予測しやすくします。これにより、ユーザーや開発運用者はソフトウェアの変更内容を明確に理解し、その影響を適切に管理することができます。

=== バージョンのインクリメント
バージョンを手動でインクリメントせず、mainリポジトリへのマージをトリガーに、コミットメッセージを解析し自動的にバージョンをインクリメントします。原則として、手動でのバージョン変更を禁止します。

=== バージョン書式

`<major>.<minor>.<patch>`

major::
メジャー番号の増加は、後方互換性を維持しない破壊的変更が行われたことを示します。そのため、アップグレード中に特別な注意と十分な時間の確保してください。後方互換性を維持し、破壊的な変更を可能な限りおこさないように努めてください。

minor::
マイナー番号の増加は、後方互換性を維持する新しい機能が追加されたことを示します。

patch::
パッチ番号のみを増やすことは、後方互換性を維持するバグ修正のみが含まれていることを示し、機能的に同等であることを意図します。

=== majorバージョン「0」
メジャーバージョンがゼロの場合、初期段階の開発用で、高速開発を意味しています。破壊的な変更を伴う場合も、minorをインクリメントします。
メジャーバージョンは、以下のいずれかのタイミングで「1」とします。

- 本番リリースし、利用開始されたとき
- 複数のサービスから利用されるようになったとき

== コミットメッセージ

人間と機械が読みやすく、意味のあるコミットメッセージにするためにコミットメッセージルールとして link:https://www.conventionalcommits.org/ja/v1.0.0/[Conventional Commits] を採用します。 これは、すべてのリポジトリを対象とした共通のルールです。主要なポイントを下記に意訳して記載します。

=== コミットメッセージのフォーマット
全てのコミットメッセージは、以下の コミットメッセージフォーマットとし、準拠していない場合はコミットとパイプラインジョブがエラーになります。エラーメッセージを元にコミットメッセージのルールに準拠してください。
複数行でのコミットメッセージを記述することも可能です。記述フォーマットは、link:https://www.conventionalcommits.org/ja/v1.0.0/#%E6%A6%82%E8%A6%81[Conventional Commits] を参考にしてください。

`<type>[optional scope]: <description>`

- 例)
** feat: add Order registration api
** fix: date calculations
** docs: add usage for drawio
** feat!: modify existing api interface


=== コミットメッセージタイプ

コミットメッセージのフォーマットの `<type>` について説明します。コミットメッセージの記述時に適切なものをプレフィクスとして設定してください。

- `feat` ・・・ 後方互換性を維持する新しい機能を追加した場合に設定します。<minor>バージョンがインクリメントされます。
- `fix` ・・・ 後方互換性を維持するバグ修正のみが含まれていることを示し、機能的に同等な場合に設定します。<patch>バージョンがインクリメントされます。
- `ci`・・・パイプラインの追加・修正した場合に設定します。
- `docs`・・・ドキュメント追加・修正した場合に設定します。
- `refactor`・・・リファクタリングのみで、機能的に同等な場合に設定します。
- `build`・・・buildスクリプトを追加・修正した場合に設定します。
- `test`・・・testコードを追加・修正した場合に設定します。
- `chore`・・・上記に該当しないその他の雑務した場合に設定します。

=== 破壊的な変更

後方互換性を維持しない破壊的な変更を行った場合は、typeの後ろに「!」を設定します。

- 例)
feat!: modify api interface

== 静的解析

セキュリティとコード品質を担保するため、静的解析のルールを定めます。静的解析のルールは、初期の開発や、新規開発運用者が開発を始めるまでの時間を短縮するため、広く普及しているツールと設定テンプレートを初期設定ルールとします。それらのルールを開発スタイルに合わせて適時カスタマイズします。カスタマイズを提案したい場合は、変更案を起案しチームに共有します。承認された場合はルールをカスタマイズします。

静的解析は、ソフトウェアコンポジション分析とコンテナ脆弱性診断を除きコミット前とパイプラインの双方で実施します。静的解析でエラーとなった場合は、コミットやパイプラインのジョブが失敗します。エラーメッセージを元にエラーを解消してください。

=== セキュリティ

シークレットスキャン::

APIキーやアクセストークンのハードコードを禁止します。これは、全リポジトリで共通のルールです。GitHubのパイプライン上でエラーとなった場合は、当該のAPIキーやアクセストークンを無効化してください。これは、すべてのリポジトリで共通のルールです。

ソフトウェアコンポジション分析::

日次で脆弱性が含まれているか検査します。問題が検出された場合は、自動的にプルリクエストを作成します。管理者は緊急度に応じてプルリクエストのマージとリリースを計画します。これは、すべてのリポジトリで共通のルールです。

- Critical/High 即時に対応すべき内容です。
- それ以外(Medium/Low/None) 任意のタイミングで実施します。

コンテナ脆弱性スキャン::

CIパイプラインと日次で脆弱性が含まれているか検査します。問題が検出された場合は、自動的にIssueを作成します。管理者は緊急度に応じて対応を計画します。

- Critical/High 即時に対応すべき内容です。
- それ以外 任意のタイミングで実施します。

これは、コンテナイメージを作成するリポジトリの共通ルールです。

=== コード品質チェック

コード品質を一定に保つために、コードフォーマットとバグ検出解析をおこないます。言語によって異なるためフロントエンドとバックエンドでルールが異なります。

==== フロントエンド
link:https://github.com/airbnb/javascript[ESLint-airbnb]を初期設定とします。

ESLint-airbnb::

主要なルールは以下です。詳細は、link:https://github.com/airbnb/javascript[原文]または、link:https://github.com/mitsuruog/javascript-style-guide[日本語訳]を参照してください

- インデント : スペース x 2
- 変数名や関数名は、camelcase。
- クラス名は、pascalcase
- 文字リテラルは、シングルクオート
- セミコロンは省略しない
- varは関数の最上部のみ
- 1ファイル内に１クラス

==== バックエンド

link:https://flake8.pycqa.org/en/latest/[Flake8]を初期設定とします。

Flake8::
主要なルールは以下です。詳細は、link:https://pep8-ja.readthedocs.io/ja/latest/[日本語訳]を参照してください

- インデント : スペース x 4
- インデントはスペースが望ましい。タブとスペースを混ぜるのは禁止。
- 1行は79文字まで。
- 「I」や「O」は紛らわしいので変数に使わない。
- 関数名、モジュール名はすべて小文字
- 定数はすべて大文字で、単語はアンダースコア区切り

== レビュー
UIデザインレビューとコードベースレビューのルールを定めます。これにより、一人では見過ごしてしまうかもしれないバグを見つけ出したり、UIデザインの洗練、コードの最適化、品質向上、レビューの効率化を図ります。

UIデザインレビューは、ワイヤーフレームとモックアップを対象とし段階的に実施します。ワイヤーフレームで大枠を合意し、モックアップでデザインと重要な動きを合意します。UIデザインレビューは、ステークスホルダーを招集しウォークスルー形式のセッションで同期的にレビューを受けます。これらは、プロダクトバックログ作成前に行われます。

コードベースレビューは、ドキュメントやプロダクトコード、テストコードを対象としスプリント中に実施します。コードベースレビューは、原則としてGitHubのプルリクエストを作成し開発運用者へ依頼します。

レビューとしては、他にスプリントレビューが存在します。スプリントレビューは、スクラムチームおよび、ステークスホルダーのフィードバックや協力を引き出すために行われ、製品価値を最適化するために次に何ができるかを参加者全員で話し合います。詳細は、スクラム運営ルールのスプリントレビューを参照してください。

=== レビュー方法

GitHubのプルリクエストに対する非同期的なレビューまたは、ウォークスルー形式のセッションで同期的にレビューを実施します。設計段階など、内容が複雑で複数回のやり取りが発生する場合は、コミュニケーションコストを軽減するためにウォークスルー形式のセッションの計画を推奨します。

==== GitHubのプルリクエストに対するレビュー

コードやドキュメントなどの変更は、GitHubのプルリクエスト上でレビューコメントを通じて非同期に実施します。

レビュー作業は、**非常に優先度の高い業務** です。即時に対応出来ない場合は、XX時頃回答しますなどクイックな応答をしてください。集中的なタスク（コーディングなど）をレビューのために中断する必要はありませんが、作業の節目、打ち合わせ後および、昼食後などキリの良いタイミングで優先的に実施してください。**１日に以内にレビューを完了** してください。

レビューコメントのプレフィクス::
修正の意図を簡潔に伝えるために、レビューコメントにプレフィクスを設定します。 `must` は、必須の対応です。

`[<type>] <コメントを自由記述>`

* type
** must 修正が必須だと思うこと
** imo 個人的に変えたほういいと思うこと
** nits 重箱の隅をつつくようなこと
** info ただのアドバイスや共有事項。こうやったらもっと簡単に書けるなど。
** ask ただの質問で、修正を望むものではない内容

* 例）
** [must] バグがある。XXXの場合に正しく動作しない。
** [imo] 変数名の宣言の順番を変えた方がいいと思う。
** [nits] コメントにタイポがある。tesst→test
** [info] XXXX じゃなく、yyyyって書いた方が簡潔になってわかりやすい。
** [ask] なぜこの処理が必要なんでしょうか。


==== ウォークスルー形式のセッションレビュー

レビュイーがドキュメントやコードなどの資料を準備し**事前に共有**したうえで、セッションを計画し同期的にレビューを受けます。レビュー内容をその場で反映できるように準備してください。**その場で修正**することで、繰り返しのレビューを避けることが出来ます。

レビュアーは、事前提供された資料をセッション前に一読してください。セッションでは、レビューコメントのプレフィクスと同様に**明確な意図**を伝えてください。

セッションフロー::
基本的な流れは、下記です。レビューをする人は適時質問してください。

1. レビューを受ける人が、セッション目的を共有します。
2. レビューを受ける人が、レビューポイント(困っていること。悩んでいることなど)を共有します。
3. レビューを受ける人が、資料説明します
4. レビューをする人が、レビューコメントします。
5. レビューを受ける人は、可能な範囲でその場でドキュメントやコードを修正します。

=== レビューの重要なポイント

==== UIデザインレビュー

UIデザインは、属人性が高くなりがちで使ってみると使いずらいなど手戻りすることが多いです。利用シーンを想像し魂を込めてレビューしてください。

- ユーザが画面を見ただけで機能を理解でき、目的に導くことのできる設計になっているか。
- システム内で一貫性があり、他システムと馴染みのあるデザインになっているか。
- ボタンやコンポーネントの不足が無いか。
- 操作誤りを予防できるか。
- 誤操作を訂正できるか。
- エラーや問題発生時に利用者がどのようにすればいいか判断できるか。

==== コードベースレビュー

よかったことのフィードバック::
変更のなかに優れたアイデアや変更、リファレンスとすべき実装があった場合にレビュイーやチームにそれを伝えてください。レビューでは間違いのみに焦点を当てることがよくありますが、**優れた変更に対しても評価やコメント** を伝える必要があります。

レビュー対象::
原則として、**全ての変更行を確認** してください。また、必要に応じてコンテキストを確認してください。コンテキストとは、差分以外の関数やクラス、ファイル全体などを指します。ファイル全体を見ることで、変更は新たな関数として切り出すなどより小さなメソッドに分割する必要があることがわかります。ほとんどのシステムは、時間経過と共に変更が積み重なることで複雑になるため、新しい変更における小さな複雑ささえ防ぐことが重要です。
代表的なレビュー対象外のコードとして、機械的な変更があげられます。多くの場合は確認する必要は無いかもしれません。ですが、機械的な変更でさえも、人的な判断が必要なことがあります。機械的な変更を盲目的に信用せずに、注意深く精査する必要がないか考えてください。

可読性の高いコード::
**コードを読むのが難しすぎ** てレビューが遅くなっている場合は、レビュイーにそのことを伝えてください。レビュイーが明確にするのを待ってからレビューしてください。レビュアーがコードを理解できない場合、他の開発運用者も理解できない可能性が高いです。**レビュイーにコードを明確にするように依頼してください。** 「難しい」、「わからない」と言うのは勇気が必要かもしれません。ですが、あなたのその一言が、別の開発運用者を助けることになり、コードの可読性を維持することに繋がります。

並列実行::
理論的にデッドロックや競合状態を引き起こす可能性があるか着目してください。この種の問題は、コードを実行するだけでは検出するのが非常に難しく、通常はレビュイーとレビュアーの両方が問題を注意深く検討して、問題が発生していないことを確認する必要があります。コードが非常に複雑になり理解が難しい可能性があります。非同期では時間が掛かることが多いため、**ウォークスルー形式のセッションを計画して同期的なレビュー** をしてください。

TIP: デッドロックの予防策は、テーブルの更新順序と更新単位が重要になります。①親子関係のあるテーブルは親側から更新しているか。②同階層テーブルはアルファベット順に更新しているか。③最上位テーブルは１行単位で更新しているか。

オーバーエンジニアリング::

レビュイーがコードを必要以上に汎用化したり、現在システムに必要のない機能を追加したりするオーバーエンジニアリングをしていないか特に注意する必要があります。レビュイーが将来解決する必要があると推測する問題・機能ではなく、**いま解決しなければならない問題** や **いま必要な機能** を実装するように伝えてください。将来必要な機能や問題は、それが必要となったタイミングで、具体的な要件や解決方法がわかります。

わかりやすい名前::

ファイル名、クラス名、関数名および変数名などの名称が適切な名前になっているか。適切な名前とは、長すぎて読みにくくならずに、項目の内容や機能を十分に伝えるのに十分な長さであることを指します。同じ内容を違う言葉で表現されることが増えすぎないように、類似名称が既にある場合はそれらを案内してください。

最低限の必要十分なコメント::

コメントはコードが必要な理由を記載します。一部の例外を除き、**コードが何を実行しているかを説明するべきではありません。** コード自体が説明できるほど明確ではない場合は、コードをより単純にする必要があります。一部の例外とは、正規表現や複雑なアルゴリズムです。何を行っているかを説明するコメントから大きなメリットが得られることがよくあります。**ほとんどのコメントは、決定の背後にある理由など、コード自体には含まれない可能性がある情報を提供するためのものです。**

ドキュメントの修正漏れ::

コード追加・変更に伴って、必要なドキュメント変更が不足していないか確認してください。ドキュメント修正が不足している場合は、必ず指摘してください。

- ビルド、テスト、操作、またはリリースする方法が変更される場合はREADMEが更新されていること。
- リファレンスや設計書などの関連ドキュメントも更新されること
- デザイン変更があった場合は、手順書などのドキュメントが更新されていること
- コードを削除または非推奨にする場合は、ドキュメントも削除する必要があるかどうかの確認。

テストコード::

テストのためにテストを作成することはなく、**テストが有効であることの確認は、レビュイーとレビュアーに委ねられています。** そのため、特に注意してレビューする必要があります。各種テストにおける共通的なルールを満たしているか確認してください。また、テストが複雑では無くシンプルで可読性の高いテストコードになっていることを確認してください。

未カバーのテストパターンやコード行::

カバレッジの数値では無く、未カバーのパターンやコード行に不具合が潜んでいないか注意を払ってください。追加のテストが必要であれば指摘してください。

可読性の高いテストコード::

** 上から下へ素直に読み下せるテストコードになっているか。
** テストコード内で過度にDRY(Don't Repeat Yourself)だったり、トリッキーなコードを書いてないか。KISS(Keep It Simple Stupid)の原則を重視し、読みやすさと意図を伝えることに重くよう伝えてください。

== テスト
各種テスト（単体テスト、結合テスト）のルールと共通ルールを定めます。単体テストは、モジュールやコンポーネントといった機能単位で機能やビジュアルに問題がないかどうかの確認を主目的とします。単体テストは、結合テストに比べ機械的なテストの実行が容易です。そのため、より多くのテストパターンを単体テストで実施することが重要です。結合テストは、それぞれの成果物(フロントエンド、バックエンド、インフラ)が正しく連携して著しく性能劣化せず、メインシナリオが動作することの確認を主目的とします。

=== テストトポロジー

本プロジェクトにおけるテストの種類と包含関係を下図に示します。

image::./test-topology.drawio.png[]

==== フロントエンドテスト

アサーションテストとスナップショットテストを分けて実施します。ビジュアル等を含めた全要素をアサーションテストで網羅するのはコストメリットに見合わないというのが実情です。ですが、ボタンサイズが小さいや、色が違う、ダイアログが裏に回って見えないなど想定外の変更が発生していないことを確認するスナップショットテストを機械的に実施することは品質を担保するうえで重要となります。

コンポーネント単位のテストは必須とせず、ページ単位でのテストを許容します。これは、コンポーネント単位でのテストを禁止するものではありません。コンポーネント単位でテストした方が効率が良い場合は、コンポーネント単位でテストしてください。

アサーションテスト::
期待値と実際の挙動を比較し、機能が正しく動いているか確認することを目的とし、期待値と実際の値を比較します。期待値と実際の値が異なる場合は、テスト結果NGとなります。正常系のみではなく､異常系の複数のパターンのテストを記述してください｡受け渡すパラメータ、振る舞い、画面遷移先が主なテスト観点となります。ここでは、基本的にビジュアル面のテストは行いません。

テスト例）

- AAAボタンを押したらBBB画面に遷移する。BBB画面に遷移しない場合は、NGです。
- XXXボタンを押したらYYYの値がZZZに変わる。YYYの値がZZZに変わらない場合は、NGです。
- バックエンドサービスAPI実行時のパラメータが、XXXになっている。XXXになっていない場合はNGです。


スナップショットテスト::
link:https://jestjs.io/docs/next/snapshot-testing[スナップショットテスト]は、ビジュアルに想定外の変更が発生していないかを確認することを目的とし、以前の出力結果と今回の出力結果を比較します。差分が発生した場合は、人の目で差分を確認し想定外の変更が発生している場合は、テスト結果NGとなります。ここでいうスナップショットとは、画像では無く、以下のようなスナップショットファイルを指します。

```
exports[`renders correctly 1`] # `
<a
  className#"normal"
  href#"http://www.facebook.com"
  onMouseEnter#{[Function]}
  onMouseLeave#{[Function]}
>
  Facebook
</a>
`;
```

テスト例）

- 前回XXXボタンを押したときのスクリーンショットと、今回XXXボタンを押したときのスクリーンショットを比較する。
** 変化がないことが期待値で、変化している場合はNGです。
** 変化があることが期待値で、変化している場合は、差分を確認して想定外の変化があれば、NGです。

==== バックエンドテスト

アサーションテスト::

期待値と実際の挙動を比較し、機能が正しく動いているか確認することを目的とし、期待値と実際の値を比較します。期待値と実際の値が異なる場合は、テスト結果NGとなります。正常系のみではなく､異常系の複数のパターンのテストを記述してください｡戻り値、ログ、エラー内容が主要なテスト観点となります。
必要に応じて、排他制御、二重実行、リトライ、データの永続化および、業務固有要件などの観点を加味して実施してください。

テスト例）

- XXX関数の戻り値がYYYである。戻り値がZZZの場合はNGです。
- XXX関数のログは、YYYと出力する。ログがZZZの場合はNGです。
- XXX関数のエラー内容は、YYYである。エラー内容がZZZの場合はNGです。

==== 結合テスト

開発環境のリソース上で、変更したバージョンでフロントエンドからバックエンドが正しく疎通することを主目的とする。

テスト観点::

- **インフラ・サービス連携**
** フロントエンドサービス、バックエンドサービス間で連携できているか。
** フロントエンドサービス、バックエンドサービスから インフラリソースにアクセスできているか。
- **主要なユーザーストーリー** に異常が無いか。
** 利用者とシステムに取って重要な機能のみを主要なユーザーストーリーとします。
- **性能**として、応答速度が著しく遅くないか。
** フロントエンドは、目安として3000ms以内に応答すること。
** バックエンドは、目安として500ms以内に応答すること。

=== 各種テストにおける共通ルール

テストメソッドの適切な命名::

* テストメソッド名が適切に設定します。日本語のテストメソッド名は非推奨です。以下を表現してください。
** 必須
*** テスト対象のメソッド名
** 推奨
*** プレフィクスにtestを設定
*** 想定動作
*** テストシナリオ

* 例
** addOrderメソッドに対するテストの例
*** addOrderSuccessWhenEmptyList
*** addOrderFailWhenInvalidDate
*** addOrderFailWhenNull

抜け漏れの無い必要最小限のテストパターン::

- 閾値の境界
- **主要な**条件分岐の網羅


実際の利用を想定したテストデータの設定::

実際の利用を想定したテストデータでテストします。「あああ」、「テスト１」ではなく、「菅野太郎」や「株式会社XXXXXX」などにします。
これは、認知負荷の軽減と要件漏れの検出に有益です。

認知負荷の軽減::
テストデータ値に実際のユースケースに近いデータを設定することで妥当性確認が容易となり、テスト結果や動きを確認する際の認知負荷が軽減されます。
例えば、テストデータが、「あああ」で名前項目に「あああ」と表示されていた場合に、「あああ」が名前なのか即座に認識することは出来ず「あああ」が何か確認する必要があります。名前項目のテストデータが、「菅野太郎」であればそのようなことは起こりません。

要件漏れの抽出::
テストケースを考える時には、それまで検討を重ねてきた要件定義や設計内容がベースになりますが、そもそも要件として認識されていないものが実際のデータに含まれている可能性があります。テストデータ値に実際のユースケースに近いデータを設定することは、要件漏れの検出に有益に作用します。

冪等なテスト::
いつでも、どこでも、誰がどんな順番で何度実行してもパスしなければなりません。そのため、実行順序や実行環境、データベース上の既存データ、システム日時といった要素に依存したテストを書いてはなりません。前処理、後処理を使ってテストに必要なデータの作成と削除を実行してください。依存コンポーネントによりテスト結果が変わる場合は、[テストダブル](https://ja.wikipedia.org/wiki/%E3%83%86%E3%82%B9%E3%83%88%E3%83%80%E3%83%96%E3%83%AB)を利用してください。例えば、システム日時を取得するような実施の度に変化する値を入力値を固定したい場合は、スタブを利用してください。

データの更新や削除を伴う場合の事前検証::

冪等なテストを保証するためにデータの更新や削除を伴うテストを書く場合は、 before/afterの両方の値を検証します。

- 更新なら、AがBに変わったことを検証します。つまり、最初はAであったことを確認します。
- 削除なら、Aが消えたことを検証します。つもり、最初はAが存在していたことを検証します。

テストカバレッジ::
一定の品質を担保するために、リポジトリ毎に下限値と目標値を定めることを推奨します。
ですが、システムに取って重要な機能の品質を担保するためには、カバーされている行の割合よりも、**カバーされていない実際のコード行 (および動作) に対する人間の判断が重要になります**。テストコードの実装者とレビュアーは、**カバーされていないパターンやコード行に注意を払ってください** 。カバレッジが十分であったとしてもカバーされていないパターンやコード行が重要だったり、懸念がある場合はテストを追加してください。

=== 情報管理
情報の整合性と利用の効率向上、情報のセキュリティ維持およびプライバシー保護目的とし、情報管理ルールを定めます。これにより、情報資産を最大限に効率的に活用するとともに潜在的な負の影響から情報を保護します。

==== 管理先ツールと想定用途

* Teams(MS Teams)
** 記録として残す必要のない通知や作業依頼、進捗共有、雑談などの情報のみを取り扱う。後続の参加者が過去の経緯にあたるような情報を知れるようにするため。
* Discussion(GitHub Discussion)
** Issueになるまえの新機能・要望などディスカッションであったり、よろず相談・質疑応答などの情報を取り扱う。
* Issue(GitHub Issue)
** チケット管理ツールで扱うような情報を取り扱う。プロダクトバックログやスプリントバックログ、不具合対応やタスクなど。
* README(GitHub Repositoryの説明)
** 開発を始めるまでの方法やサービスの起動方法などリポジトリ固有の利用方法を記載
* Wiki(GitHub Wiki)
** 軽量な厳密なバージョン管理を必要としないようなドキュメントを取り扱う。ルールおよび手順書、調査記録など。
* Pages(GitHub Pages)
** 設計書などコードとセットでバージョン管理が必要な情報を取り扱う。


==== 管理先ツールと情報の対応表

* 〇以外のところでやり取りした場合は、転記すること。
* 関連する情報はリンクすること。
* リポジトリ固有の各種方法とは、たとえばテスト方法など

[cols="5,2,2,2,2,2,2"]
|===
| 情報                         | Teams | Issue | Wiki | Discussion| Pages |README

| システムからの通知            |  〇  |        |      |            |       |
| 作業依頼                     |  〇  |        |      |            |       |
| 進捗共有                     |  〇  |        |      |            |       |
| 雑談                         |  〇  |        |      |            |       |
| 要求や要件                   |      |   〇   |      |            |       |
| 不具合対応                   |      |   〇   |      |            |       |
| タスク                       |      |   〇   |      |            |       |
| 設計                         |      |        |     |            |   〇  |
| 開発ルール                   |      |        |  〇  |          　|       |
| インセプションデッキ          |      |        |  〇  |          　|       |
| スクラム運営ルール            |      |        |  〇  |          　|       |
| ディスカッションペーパ        |      |        |  〇  |          　|       |
| 技術調査記録                 |      |        |  〇  |          　|       |
| 障害調査記録                 |      |        |  〇  |          　|       |
| 手順書                      |      |        |  〇  |            |       |
| Loacal開発環境のセットアップ |      |        |  〇  |            |       |   〇
| サービス起動方法            |      |        |  〇  |            |       |   〇
| リポジトリ固有の各種方法     |      |        |  〇  |            |       |   〇
| 手順書                      |      |        |  〇  |            |       |
| 新機能提案・要望             |      |        |      |    〇      |       |
| なんでも相談                 |      |        |      |    〇      |       |
| インシデント報告             |      |        |      |    〇      |       |
| 質疑応答                    |       |   〇   |      |    〇      |       |
|===

==== ファイル形式
- 図
** drawio (.drawio.png)
- uml
** plantuml (.pu)
- ドキュメント
** Pages(設計書) adoc (.adoc)
** Wiki(その他) markdown(.md)

==== 機密情報の取り扱い
情報管理ツール上に機密情報を取り扱ってはならず、記載する場合は個人が特的出来る情報の匿名加工やシークレット情報のマスキングを必須とする。

機密情報の例
- 個人を特定できる情報（生年月日や名前など）
- シークレット情報（パスワードやトークンなど）


==== 情報管理系機能群の説明

GitHub Discussions は、共同コミュニケーション フォーラムです。 メンバーは、質問をしたり、質問に答えたり、最新情報を共有したり、自由形式の会話をしたりプロジェクトの動向に影響を与える決定をフォローしたりすることができます。

link:https://docs.github.com/ja/issues/planning-and-tracking-with-projects/learning-about-projects/about-projects[GitHub Projects]::

Projects は、GitHub での作業を計画および追跡するための、適応性のある柔軟なツールです。プロジェクトは、作業の計画と追跡を効果的に行えるようにGitHub 上の issue および pull request と統合できる、適応性のあるスプレッドシート、タスク ボード、ロード マップです。 issue と pull request をフィルター処理、並べ替え、グループ化することで複数のビューを作成してカスタマイズしたり、構成可能なグラフを使って作業を視覚化したり、team 固有のメタデータを追跡するためのカスタム フィールドを追加したりすることができます。 プロジェクトには、特定の手法を適用するのではなく、チームのニーズやプロセスに合わせてカスタマイズできる柔軟な機能があります。


link:https://docs.github.com/ja/repositories/creating-and-managing-repositories/about-repositories[GitHub Repositories]::
リポジトリは、GitHub の最も基本的な要素です。 これは、コード、ファイル、各ファイルのリビジョン履歴を格納できる場所です。 リポジトリは、複数のコラボレーターが参加することができ、公開用またはプライベートのいずれかにできます。

link:https://docs.github.com/ja/issues/tracking-your-work-with-issues/about-issues[GitHub Issue]::
GitHub Issuesを使って、GitHubでの作業に関するアイデア、フィードバック、タスク、バグを追跡できます。

link:https://docs.github.com/ja/communities/documenting-your-project-with-wikis/about-wikis[GitHub Wiki]::
GitHub.com のすべてのリポジトリには、Wiki と呼ばれるドキュメントをホストするためのセクションが用意されています。 リポジトリのウィキは、プロジェクトの利用方法、設計方法、中核的な原理など、プロジェクトに関する長いコンテンツを共有するために利用できます。 README ファイルは、プロジェクトができることを手短に述べますが、ウィキを使えば追加のドキュメンテーションを提供できます。

link:https://docs.github.com/ja/pages/getting-started-with-github-pages/about-github-pages[GitHub Pages]::
GitHub Pages は、GitHub のリポジトリから HTML、CSS、および JavaScript ファイル を直接取得し、任意でビルドプロセスを通じてファイルを実行し、ウェブサイトを公開できる静的なサイトホスティングサービスです。 GitHub Pages サイトの例は、link:https://github.com/collections/github-pages-examples[GitHub Pages サンプル コレクション]で確認できます。
